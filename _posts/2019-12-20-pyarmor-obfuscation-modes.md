---
title: 'Obfuscation Modes in PyArmor'
date: 2019-12-20
permalink: /posts/2019/12/pyarmor-obfuscation-modes/
tags:
  - obfuscation
  - pyarmor
  - python
---

I think one of the unique features provided by PyArmor is that it lets the users to configure the ways to obfuscate the codes.

This is achieved through obfuscation modes. Here's what written on the <a href="https://pyarmor.readthedocs.io/en/latest/mode.html">docs</a>.

```
PyArmor could obfuscate the scripts in many modes in order to balance the security and performance. In most of cases, the default mode works fine. But if the performance is to be bottle-block or in some special cases, maybe you need understand what the differences of these modes and obfuscate the scripts in different mode so that they could work as desired.
```

In a nutshell and apart from the advanced mode, PyArmor provides two modes of obfuscation. The first one is for code object, while the second one is for the whole module.

<h2>Code Object Obfuscation Modes</h2>

A python module might consist of one or more functions. In a python module file, generally there are many functions and each function consists of its code object.

The followings are the available modes for code object obfuscation:
<ul>
<li><b>obf_code = 0</b>
  <p>
The code object of each function won't be obfuscated
  </p>
</li>
<li><b>obf_code = 1</b> (default)
  <p>
The code object of each function will be obfuscated in different ways depending on the selected wrap mode
  </p>
</li>
<li><b>obf_code = 2</b>
  <p>
  Same as <b>obf_code = 1</b>, yet the code object's bytecode is obfuscated using a more complex algorithm. This causes the obfuscation process slower than <b>obf_code = 1</b>
  </p>
</li>
</ul>

Since <b>obf_code = 1</b> and <b>obf_code = 2</b> depend on the chosen wrap mode, here are the available wrap modes.

<ul>
<li><b>wrap_mode = 0</b>
<p>
When the code object is called first time, PyArmor will do the followings.
<p>
  a) Execute <i>__armor__</i> function. This function will restore the obfuscated bytecode of the code object<br/>
b) The deobfuscated bytecode is executed<br/>
</p>

After performing the above actions, the code object of the function won't be re-obfuscated.
</p>
</li>
<li><b>wrap_mode = 1</b> (default)
<p>
  Using this mode, he code object of each function will be wrapped with a <i>try...finally</i> block.

When this code object is called first time, PyArmor will do the followings:
<p>
  a) Execute <i>__armor_enter__</i> function. This function restores the obfuscated bytecode of the code object<br/>
b) Execute the deobfuscated bytecode<br/>
  c) Execute <i>__armor_exit__</i> function. This function will obfuscate the bytecode again<br/>
</p>

As you can see, the bytecode will be re-obfuscated each time it has been executed. That's the primary purpose of the <i>try...finally</i> block in this case.
</p>
</li>
</ul>

<h2>Module Obfuscation Modes</h2>

These modes are used to configure how PyArmor should obfuscate the whole module.

The available modes are:

<ul>
<li><b>obf_mod = 1</b> (default)
  <p>
The obfuscated module will have the following content.

<p>
  <br/>
  <i>__pyarmor__(__name__, __file__, b'\x02\x0a...', 1)</i>
</p>

The third parameter is the obfuscated bytecode of the module. It's generated by the following way:

<p>
  <br/>
<i>
PyObject *co = Py_CompileString( source, filename, Py_file_input );<br/>
obfuscate_each_function_in_module( co, obf_code );<br/>
char *original_code = marshal.dumps( co );<br/>
char *obfuscated_code = obfuscate_whole_module( original_code  );<br/>
sprintf( buffer, "__pyarmor__(__name__, __file__, b'%s', 1)", obfuscated_code );<br/>
</i>
</p>

In short, the above code does the followings:
<p>
a) Generates the code object of the module<br/>
b) Obfuscates code object for each function<br/>
c) Serializes the module's code object (with the obfuscated code object for each function)<br/>
d) Obfuscates the serialized module's code object<br/>
</p>

Please check the <b>Code Object Obfuscation Modes</b> section for all the configurations available for obfuscating a code object.
</p>
</li>
<li><b>obf_mod = 0</b>
  <p>
The obfuscated module will have the following content.

<p>
  <br/>
  <i>__pyarmor__(__name__, __file__, b'\x02\x0a...', 0)</i>
</p>

This mode does not obfuscate the code object of the whole module. The third parameter of the above script denotes the serialized module's code object. This third parameter is generated by the followings:

<p>
  <br/>
  <i>
PyObject *co = Py_CompileString( source, filename, Py_file_input );<br/>
obfuscate_each_function_in_module( co, obf_code );<br/>
char *original_code = marshal.dumps( co );<br/>
sprintf( buffer, "__pyarmor__(__name__, __file__, b'%s', 0)", original_code );<br/>
  </i>
</p>
</p>
</li>
</ul>

For more detail explanation on how a code object is obfuscated, please visit this <a href="https://albertuskelvin.github.io/posts/2019/12/code-obfuscation-with-pyarmor/">post</a>.
